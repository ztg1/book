### 摘要

---

​		现在很多主流的编程语言都支持多线程或者协程处理，例如天生支持协程的`go语言`、`php+swoole`等。但是多线程和单线程不同，多线程如果不对数据库做处理的话，有时候单线程跑的程序没有问题，但是一旦开启多线程，数据库就会发生一系列之前没有的问题。

​		那么多线程高并发的数据库需要做怎样的处理呢？下面以`PHP+MySQL`为例做说明，其他编程语言类似。



### 数据库处理

---

并发数据库处理最低条件必须满足下面的前6条



#### 事务

​		事务是多线程处理中确保数据准确性和一致性的核心步骤之一，但前提是MySQL数据库的存储引擎必须是*InnoDB*，因为MyISAM不支持事务，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；

例如php-laravel框架中的事务：

```php
try {
    DB::beginTransaction();
    
    //业务逻辑和数据库操作
    
    DB::commit();
} catch (Exception $e) {
    DB::rollback();
    echo $e->getMessage();
}
```



#### 行锁

​	行锁是多线程处理中确保数据准确性和一致性的第二个核心步骤，加行锁能保证在这个事务中的数据不会被其他线程更改，确保数据准确，其他线程访问这一行时会阻塞；需要注意的是，行锁只能锁定一行，如果数据库where条件中包含多行结果将会报错

例如php-laravel框架事务中的行锁：

```php
try {
    DB::beginTransaction();
    
    //lockForUpdate()表示加行锁进行更新
    $user = User::where('id',1)->lockForUpdate()->first();		//可行
    $user = User::where('id','>',1)->lockForUpdate()->first();	//这是不行的，会报错
    $user->name = 'test';
    $user->save();
    
    DB::commit();
} catch (Exception $e) {
    DB::rollback();
    echo $e->getMessage();
}
```



#### 索引

​		`InnoDB`的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。



#### 禁止的操作

在有行锁的事务中不可以进行以下的操作

- 自增自减

  很多编程语言框架的orm都提供自增自减连贯操作，但是在行锁事务中事不允许的，例如

  ```php
  User::where(['id'=>1])->increment('stock');
  User::where(['id'=>1])->decrement('stock');
  ```

  

- 查询语句在事务外面

  数据查询的执行必须在事务开始后，否则不起作用



#### 执行顺序

​	假如你的事务中的lockForUpdate操作的数据表依次为A、B、C表，那么你更新表的顺序也应该按A、B、C表的顺序更新；

​	假如你的两条相同逻辑并发线程分别需要锁定相同的数据表，那么锁定的表顺序应该保持一致。举个反向案例：两条线程分别锁定顺序为A、B、C和B、A、C，当两线程同时执行，当线程1锁定A表，需要接着锁定B表，但是B表已经被线程2锁定；线程2此时也在等待线程1释放A表，这样两条线程相互等待造成会死锁。



#### 连接池

​	多线程情况下数据库连接如果用同一个连接实例，可能会发生报错，这个视编程语言框架而定，有的框架已经帮忙处理好了，但是大多数需要配置才能生效。连接池的应用大大降低了数据库的连接资源占用和访问速度。



#### 读写分离（可选）

​	当数据库的写压力增加，读写集中在一个数据库上会让数据库不堪重负。读写分离就是建立多个分布式数据库，只在主数据库服务器上写，只在从数据库服务器上读，其中从数据库服务器可以部署多台用来读数据。一般编程语言的orm都支持读写分离配置。



#### 分库分表（可选）

​		随着系统访问量的增加，QPS越来越高，数据库磁盘容量不断增加，一般数据库服务器的QPS在800-1200的时候性能最佳，当超过2000的时候sql就会变得很慢并且很容易被请求打死，而单表数据量过大也会导致数据库执行sql很慢，为了应付这种场景产生了分库分表这种思想和技术。MySQL的话可以考虑使用分布分表中间件，例如`mycat`。另外如果单张表数据过大，查询起来速度会很慢，对时间要求不大的情况下，考虑建立历史表。



#### 使用缓存（可选）

​		为了减少对数据库的访问，对时效性低的数据可以使用缓存数据库，提高访问速度，例如redis和memcacha。



#### 负载均衡（可选）

​	负载均衡，也称分布式服务器，如果用户量很大，一台服务器无法支撑服务，需要部署多台服务器，做负载均衡处理。例如使用阿里云的负载均衡或者自行搭建nginx反向代理。另外，缓存服务器也是可以可以分布式搭建的



### 常见报错

报错信息：

```bash
ERROR : (2006, 'MySQL server has gone away')
```

解决方法：

事务中有锁等待问题导致数据库阻塞，检查你的事务中是否有事务没提交，return、continue或break前是否已经rollback



报错信息：

```bash
[ERROR] Uncaught exception 'Illuminate\Database\QueryException': [0]Packets out of order. Expected 15 received 1. Packet size=80
```

解决方法：

检查事务中的锁行语句是否包含多行，多行只能锁一行，也就是说你查询条件的字段必须是唯一的；

或者检查是否有启用数据库连接池，多个线程使用同一数据库连接也会出现这个问题



报错信息：

```bash
ERROR 1305(42000) SAVEPOINT trans*** DOES NOT EXIST
```

解决方法：

有部分事务没有提交或者回滚，检查你的事务中是否有事务没提交，return、continue或break前是否已经rollback