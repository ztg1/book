





## 一、错误处理

### 错误和异常如何区分？

   **错误**有可能出现问题出现的地方出现了问题，比如打开一个文件失败等，这种是我们开发中意料之中。

   **异常**是不应该出现问题的地方出现了问题，比如引用了空指针这种是人们的意料之外。

   可见错误是业务的一部分，二异常不是。



### Golang错误和异常是可以互相转换的

1. 错误转异常，比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试完第三次还不成功的话，失败就被提升为异常了。
2. 异常转错误，比如panic触发的异常被recover恢复后，将返回值中error类型的变量进行赋值，以便上层函数继续走错误处理流程。

### 异常处理的作用域（场景）

1. 空指针引用
2. 下标越界
3. 除数为0
4. 不应该出现的分支，比如default
5. 输入不应该引起函数错误

## 错误处理的正确姿势

一：失败的原因只有一个时，不使用error。

二：没有失败时不适用error。

三：error应放在返回值类型列表的最后。

四：错误值统一定义，而不是跟着感觉走。

五：错误逐层传递时，层层都加日志。

六：错误处理使用defer。

       ```powershell
当Golang的代码执行时，如果遇到defer的闭包调用，则压入堆栈。当函数返回时，会按照后进先出的顺序调用闭包。

对于闭包的参数是值传递，而对于外部变量却是引用传递，所以闭包中的外部变量err的值就变成外部函数返回时最新的err值。
       ```

七：当尝试几次可以避免失败时，不要立即返回错误。

```powershell
1、我们平时上网时，尝试请求某个URL，有时第一次没有响应，当我们再次刷新时，就有了惊喜。

2、团队的一个QA曾经建议当Neutron的attach操作失败时，最好尝试三次，这在当时的环境下验证果然是有效的。
```

八：当上层函数不关心错误时，建议不返回error。

九：当发生错误时，不忽略有用的返回值。

>   **说明：对函数的返回值要有清晰的说明，以便于其他人使用。** 





## 异常处理的正确姿势

1、在程序开发阶段，坚持速错

2、在程序部署后，应恢复异常避免程序终止

> 在Golang中，虽然有类似Erlang进程的Goroutine，但需要强调的是Erlang的挂，只是Erlang进程的异常退出，不会导致整个Erlang节点退出，所以它挂的影响层面比较低，而Goroutine如果panic了，并且没有recover，那么整个Golang进程（类似Erlang节点）就会异常退出。所以，一旦Golang程序部署后，在任何情况下发生的异常都不应该导致程序异常退出，我们在上层函数中加一个延迟执行的recover调用来达到这个目的，并且是否进行recover需要根据环境变量或配置文件来定，默认需要recover。
> 这个姿势类似于C语言中的断言，但还是有区别：一般在Release版本中，断言被定义为空而失效，但需要有if校验存在进行异常保护，尽管契约式设计中不建议这样做。在Golang中，recover完全可以终止异常展开过程，省时省力。
>
> 我们在调用recover的延迟函数中以最合理的方式响应该异常：
>
> 1. 打印堆栈的异常调用信息和关键的业务信息，以便这些问题保留可见；
> 2. 将异常转换为错误，以便调用者让程序恢复到健康状态并继续安全运行。



3、对于不应该出现的分支，使用异常处理。

4、针对入参不应该有问题的函数，使用panic设计。











